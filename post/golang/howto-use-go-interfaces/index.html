<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Verdana's Notebook</title>
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="http://phpvim.net/css/normalize.css">
    <link rel="stylesheet" href="http://phpvim.net/css/skeleton.css">
    <link rel="stylesheet" href="http://phpvim.net/css/style.css">
    <link rel="icon" type="image/png" href="http://phpvim.net/images/favicon.png">
</head>

<body>


    <div class="container">
        <header class="u-cf topinfo">
    <code><a href="http://phpvim.net/">@verdana</a></code>
    
    <code><span class="post-lastmod">2018, Mar 29</span></code>
    
    <code><span>Blogs </span><span class="post-count">6</span></code>
    <code><span>Views </span><span class="post-views">999</span></code>
</header>


        <article class="post-content">
            

<p>我偶尔会在我的日常工作上免费进行咨询和代码审查。因此，我倾向于阅读很多其他人的代码。虽然这很可能是错觉，但我真的看到了很多我称之为 Java 风格的接口用法。</p>

<p>这篇博文是 Go 的具体建议，基于我写Go代码的经验，以及如何很好地使用接口。</p>

<p>For this blog post, the running example will span two packages: animal and circus. A lot of what I write about here is about code at the boundary of packages.</p>

<h2 id="别这么干">别这么干</h2>

<p>我看到很多人的接口是这样用的：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">package</span> <span style="color:#000">animals</span>

<span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Animal</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000;font-weight:bold">{</span>
	<span style="color:#000">Speaks</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#204a87;font-weight:bold">string</span>
<span style="color:#000;font-weight:bold">}</span>

<span style="color:#8f5902;font-style:italic">// implementation of Animal
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Dog</span> <span style="color:#204a87;font-weight:bold">struct</span><span style="color:#000;font-weight:bold">{}</span>
<span style="color:#204a87;font-weight:bold">func</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#000">Dog</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000">Speaks</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#204a87;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#4e9a06">&#34;woof&#34;</span> <span style="color:#000;font-weight:bold">}</span></code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">package</span> <span style="color:#000">circus</span>

<span style="color:#204a87;font-weight:bold">import</span> <span style="color:#4e9a06">&#34;animals&#34;</span>

<span style="color:#204a87;font-weight:bold">func</span> <span style="color:#000">Perform</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#000">animal</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">Animal</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">Speaks</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">}</span></code></pre></div>
<p>这就是所谓的 Java 风格的接口用法。通常步骤是这样的：</p>

<ol>
<li>定义一个接口</li>
<li>定义一个匹配这个接口的类型（如：Dog 结构体）</li>
<li>定义满足接口实现的方法</li>
</ol>

<p>我将这个概括为“编写类型以实现接口”。这种代码味道的人为因素很明显：</p>

<ul>
<li>其中最明显的是它只有一种类型可以实现接口，而没有明显的扩展手段。</li>
<li>函数通常采用具体的类型而不是接口类型。</li>
</ul>

<h2 id="正确的做法">正确的做法</h2>

<p>Go 接口鼓励人们懒惰，这是一件好事，而不是编写类型来完成接口，编写接口来满足使用需求。</p>

<p>我的意思是这个 - 不是在 animals package 中定义 Animal，而是在 package circus 的使用点上定义它。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">package</span> <span style="color:#000">animals</span>

<span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Dog</span> <span style="color:#204a87;font-weight:bold">struct</span><span style="color:#000;font-weight:bold">{}</span>
<span style="color:#204a87;font-weight:bold">func</span> <span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#000">Dog</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000">Speaks</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#204a87;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#4e9a06">&#34;woof&#34;</span> <span style="color:#000;font-weight:bold">}</span></code></pre></div><div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">package</span> <span style="color:#000">circus</span>

<span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Speaker</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000;font-weight:bold">{</span>
	<span style="color:#000">Speaks</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#204a87;font-weight:bold">string</span>
<span style="color:#000;font-weight:bold">}</span>

<span style="color:#204a87;font-weight:bold">func</span> <span style="color:#000">Perform</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#000">Speaker</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">string</span> <span style="color:#000;font-weight:bold">{</span> <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">a</span><span style="color:#000;font-weight:bold">.</span><span style="color:#000">Speaks</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000;font-weight:bold">}</span></code></pre></div>
<p>更舒适的方式是：</p>

<ol>
<li>定义类型</li>
<li>在使用点定义接口</li>
</ol>

<p>这种方式明显降低了对 package animals 的依赖。</p>

<h2 id="伯斯塔尔法则">伯斯塔尔法则</h2>

<p><a href="https://en.wikipedia.org/wiki/Robustness_principle">伯斯塔尔法则</a> 是创作优秀软件需要遵循的准则之一。</p>

<p>通常的说法是这样的：</p>

<blockquote>
<p>Be conservative with what you do, be liberal with you accept</p>
</blockquote>

<p>如果翻译到 Go 语言的语境中：</p>

<blockquote>
<p>Accept interfaces, return structs</p>
</blockquote>

<p>Go 中的主要代码单元是函数，设计函数/方法时应当遵循的以下的模式：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">func</span> <span style="color:#000">funcName</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">a</span> <span style="color:#000">INTERFACETYPE</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#000">CONCRETETYPE</span></code></pre></div>
<p>这里我们看到我们接受任何实现接口的东西 - 可以是任何接口或空白接口，并返回一个具体值。</p>

<p>当然，限制参数 a 的具体类型是很有必要的，最好不要在函数中传入空白接口 interface{}，没有意义。</p>

<blockquote>
<p>the empty interface says nothing - Rob Pike</p>
</blockquote>

<h2 id="使用案例-mocking">使用案例：Mocking</h2>

<p>伯斯塔尔法则的有用性的一个很好的例证就是在测试的环境中下，比如你有一个类似下面的函数：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">func</span> <span style="color:#000">Takes</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">db</span> <span style="color:#000">Database</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">error</span></code></pre></div>
<p>如果 Database 是一个接口，然后在测试代码中，您可以提供一个 Database 的模拟实现，而不必传入实际的数据库对象。</p>

<h2 id="什么时候可以接受预先定义接口">什么时候可以接受预先定义接口</h2>

<p>老实说，编程的形式是非常自由的 - 没有任何的硬性规定。你当然可以预先定义一个接口。在多个 package 的情况下，如果你知道你的函数正在使用包中的某个接口，那么通过一切手段来做到这一点。</p>

<p>预定义接口通常有点过度工程的意味。但是在很多状况下你很明显是需要预先接口的，我可以想到的是：</p>

<ul>
<li>封闭接口</li>
<li>抽象数据类型</li>
<li>递归接口</li>
</ul>

<p>Here I shall briefly visit each.</p>

<h2 id="封闭接口">封闭接口</h2>

<p>Sealed interfaces can only be discussed in the context of having multiple packages. A sealed interface is an interface with unexported methods. This means users outside the package is unable to create types that fulfil the interface. This is useful for emulating a sum type as an exhaustive search for the types that fulfil the interface can be done.</p>

<p>So what you’d define something like this:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Fooer</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000;font-weight:bold">{</span>
	<span style="color:#000">Foo</span><span style="color:#000;font-weight:bold">()</span>
	<span style="color:#000">sealed</span><span style="color:#000;font-weight:bold">()</span>
<span style="color:#000;font-weight:bold">}</span></code></pre></div>
<p>Only the package that defined Fooer can use and create any valid value of Fooer. This allows for exhaustive type switches to be done.</p>

<p>A sealed interface also allows for analysis tools to easily pick up any non-exhaustive pattern match. In fact BurntSushi’s <a href="https://github.com/BurntSushi/go-sumtype">sumtypes</a> package does just that for you.</p>

<h2 id="抽象数据类型">抽象数据类型</h2>

<p>The other use of defining an interface upfront is to create a abstract data type. It may or may not be sealed.</p>

<p>The sort package that comes in the standard library is a good example of this. It defines a sortable collection as</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Interface</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000;font-weight:bold">{</span>
    <span style="color:#8f5902;font-style:italic">// Len is the number of elements in the collection.
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#000">Len</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#204a87;font-weight:bold">int</span>
    <span style="color:#8f5902;font-style:italic">// Less reports whether the element with
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#8f5902;font-style:italic">// index i should sort before the element with index j.
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#000">Less</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">i</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">j</span> <span style="color:#204a87;font-weight:bold">int</span><span style="color:#000;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">bool</span>
    <span style="color:#8f5902;font-style:italic">// Swap swaps the elements with indexes i and j.
</span><span style="color:#8f5902;font-style:italic"></span>    <span style="color:#000">Swap</span><span style="color:#000;font-weight:bold">(</span><span style="color:#000">i</span><span style="color:#000;font-weight:bold">,</span> <span style="color:#000">j</span> <span style="color:#204a87;font-weight:bold">int</span><span style="color:#000;font-weight:bold">)</span>
<span style="color:#000;font-weight:bold">}</span></code></pre></div>
<p>Now this has made a lot of people upset - because if you want to use the sort package you’d have to implement the methods for the interface, and people for the most part are upset about having to type three extra lines.</p>

<p>However in my opinion this is a very elegant form of generics in Go. It should be encouraged more.</p>

<p>The alternative design that is elegant would require higher-kinded types. We shan’t go there in this blog post.</p>

<h2 id="递归接口">递归接口</h2>

<p>This is probably another code smell, but there are times which are unavoidable, you perform something within a monad and end up with an interface that looks like this:</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#204a87;font-weight:bold">type</span> <span style="color:#000">Fooer</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000;font-weight:bold">{</span>
	<span style="color:#000">Foo</span><span style="color:#000;font-weight:bold">()</span> <span style="color:#000">Fooer</span>
<span style="color:#000;font-weight:bold">}</span></code></pre></div>
<p>The recursive interface pattern would require the interface be defined upfront, clearly. The guideline of defining an interface at the point of use is inapplicable here.</p>

<p>This pattern is useful for creating contexts to operate in. Context-heavy code are usually self-contained within a package, with only the contexts exported (alá the tensor package), so I don’t actually see a lot of this. I’ve quite a bit more to say about contextual patterns, but I’ll leave that to another blog post.</p>

<h2 id="结论">结论</h2>

<p>Even though I have a section titled “Don’t Do This”, the purpose of this post is not meant to be proscriptive. Rather, I want to encourage people to think at the boundary conditions - that’s where all the edge cases happen.</p>

<p>I personally found the declare-at-point-of-use pattern extremely useful. As a result I don’t particularly run into issues that I’ve observed a number of people have run into.</p>

<p>I however also run into cases where I end up accidentally writing Java style interfaces - typically after I come back from a stint of writing code in Python or Java. The desire to overengineer and “class all the things” something is quite strong especially when writing Go code after writing a lot of object oriented code.</p>

<p>Hence this post also serves as a self-reminder on what the path to pain-free code looks like. Tell me what you think!</p>

<p>Thanks to <a href="https://twitter.com/nstratos">Stratos Neiros</a> for reviewing an earlier version of this article. And to Riteek Srivastava for picking out some bugs in the example code.</p>

        </article>

        <footer class="post-footer">
            
            <ul class="post-tags">
                
                <li>
                    <a href="http://phpvim.net/tags/golang"> <span class="tag">Golang</span> </a>
                </li>
                
            </ul>
            
            <p class="post-copyright">
                本作品采用<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>进行许可。
            </p>
        </footer>

        
    </div>




<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-1900757-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



</body>
</html>

